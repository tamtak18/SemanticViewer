```python
from scipy.stats import chi2

# 観測度数のデータを2次元リストとして定義
# 行は "高温" と "低温"、列は "ビール購入" と "ビール非購入" を表します
observed = [
    [30, 10],  # 高温
    [10, 50]   # 低温
]

# 行数と列数を計算
num_rows = len(observed)
num_columns = len(observed[0])

# 自由度を計算
degrees_of_freedom = (num_rows - 1) * (num_columns - 1)

# 総計、行合計、列合計を計算
total = sum([sum(row) for row in observed])
row_totals = [sum(row) for row in observed]
col_totals = [sum([observed[i][j] for i in range(num_rows)]) for j in range(num_columns)]

# 期待度数を計算
expected = [[(row_totals[i] * col_totals[j]) / total for j in range(num_columns)] for i in range(num_rows)]

# カイ二乗値を計算
chi2_value = sum(
    [
        (observed[i][j] - expected[i][j]) ** 2 / expected[i][j]
        for i in range(num_rows)
        for j in range(num_columns)
    ]
)

# p 値を計算（上側確率）
p_value = 1 - chi2.cdf(chi2_value, degrees_of_freedom)

# 結果を表示
print(f'カイ二乗値: {chi2_value}')
print(f'自由度: {degrees_of_freedom}')
print(f'p 値: {p_value}')

```

    カイ二乗値: 34.02777777777777
    自由度: 1
    p 値: 5.433087424400185e-09
    


```python
from scipy.stats import chi2

# 観測度数のデータを2次元リストとして定義
# 行は "高温" と "低温"、列は "ビール購入" と "ビール非購入" を表します
observed = [
    [22, 28],  # 明るい照明
    [18, 32]   # 暗い照明
]

# 行数と列数を計算
num_rows = len(observed)
num_columns = len(observed[0])

# 自由度を計算
degrees_of_freedom = (num_rows - 1) * (num_columns - 1)

# 総計、行合計、列合計を計算
total = sum([sum(row) for row in observed])
row_totals = [sum(row) for row in observed]
col_totals = [sum([observed[i][j] for i in range(num_rows)]) for j in range(num_columns)]

# 期待度数を計算
expected = [[(row_totals[i] * col_totals[j]) / total for j in range(num_columns)] for i in range(num_rows)]

# カイ二乗値を計算
chi2_value = sum(
    [
        (observed[i][j] - expected[i][j]) ** 2 / expected[i][j]
        for i in range(num_rows)
        for j in range(num_columns)
    ]
)

# p 値を計算（上側確率）
p_value = 1 - chi2.cdf(chi2_value, degrees_of_freedom)

# 結果を表示
print(f'カイ二乗値: {chi2_value}')
print(f'自由度: {degrees_of_freedom}')
print(f'p 値: {p_value}')

```

    カイ二乗値: 0.6666666666666667
    自由度: 1
    p 値: 0.4142161782425252
    


```python
from scipy.stats import chi2

# 観測度数のデータを2次元リストとして定義
# 行は "高温" と "低温"、列は "ビール購入" と "ビール非購入" を表します
observed = [
    [40, 10],  # カテゴリーA
    [20, 30]   # カテゴリーB
]

# 行数と列数を計算
num_rows = len(observed)
num_columns = len(observed[0])

# 自由度を計算
degrees_of_freedom = (num_rows - 1) * (num_columns - 1)

# 総計、行合計、列合計を計算
total = sum([sum(row) for row in observed])
row_totals = [sum(row) for row in observed]
col_totals = [sum([observed[i][j] for i in range(num_rows)]) for j in range(num_columns)]

# 期待度数を計算
expected = [[(row_totals[i] * col_totals[j]) / total for j in range(num_columns)] for i in range(num_rows)]

# カイ二乗値を計算
chi2_value = sum(
    [
        (observed[i][j] - expected[i][j]) ** 2 / expected[i][j]
        for i in range(num_rows)
        for j in range(num_columns)
    ]
)

# p 値を計算（上側確率）
p_value = 1 - chi2.cdf(chi2_value, degrees_of_freedom)

# 結果を表示
print(f'カイ二乗値: {chi2_value}')
print(f'自由度: {degrees_of_freedom}')
print(f'p 値: {p_value}')

```

    カイ二乗値: 16.666666666666668
    自由度: 1
    p 値: 4.455709060402491e-05
    


```python
import numpy as np
import pandas as pd
from scipy.stats import chi2_contingency
import matplotlib.pyplot as plt
import networkx as nx
import matplotlib.font_manager as fm

# 日本語フォントの設定
jp_font_path = 'C:/Windows/Fonts/meiryo.ttc'  # Windows環境でのフォントパス
jp_font = fm.FontProperties(fname=jp_font_path)

# サンプルデータの作成
np.random.seed(42)
data_size = 1000
df = pd.DataFrame({
    '年齢層': np.random.choice(['20代', '30代', '40代'], size=data_size),
    '性別': np.random.choice(['男性', '女性'], size=data_size),
    '購入回数': np.random.randint(0, 6, size=data_size),
    '購入した': np.random.choice(['購入した', '購入しなかった'], size=data_size)
})

# ターゲット変数を数値に変換
df['購入した'] = df['購入した'].apply(lambda x: 1 if x == '購入した' else 0)

# カイ二乗検定の実装
def compute_chi2(data, feature, target='購入した'):
    contingency_table = pd.crosstab(data[feature], data[target])
    chi2, p, dof, expected = chi2_contingency(contingency_table)
    return chi2, p

# 簡易的なCHAIDアルゴリズムの実装
def chaid_decision_tree(data):
    splits = {}
    
    # 初期のカイ二乗計算（購入回数に基づく）
    chi2_purchase, p_purchase = compute_chi2(data, '購入回数')
    splits['購入回数'] = {'chi2': chi2_purchase, 'p_value': p_purchase}
    
    # 初期の結果を表示
    print(f"最適な分割は '購入回数' (chi2: {chi2_purchase:.4f}, p-value: {p_purchase:.4f})")
    
    return splits

# 分割結果を保存する
splits = chaid_decision_tree(df)

# 階層的にノードを配置するためのレイアウト関数
def hierarchy_pos(G, root=None, vert_gap=0.4, vert_loc=0, xcenter=1.0, horizontal_spacing=1.0):
    pos = _hierarchy_pos(G, root, vert_gap, vert_loc, xcenter, horizontal_spacing)
    return pos

def _hierarchy_pos(G, root, vert_gap=0.4, vert_loc=0, xcenter=1.0, horizontal_spacing=1.0, pos=None, parent=None):
    if pos is None:
        pos = {root: (xcenter, vert_loc)}
    else:
        pos[root] = (xcenter, vert_loc)

    children = list(G.neighbors(root))
    if not isinstance(G, nx.DiGraph) and parent is not None:
        children.remove(parent)

    if len(children) != 0:
        dx = horizontal_spacing  # 兄弟ノードの間隔を直接指定
        nextx = xcenter - len(children) * dx / 2 + dx / 2  # ノードの開始位置を調整
        for child in children:
            pos = _hierarchy_pos(G, child, vert_gap=vert_gap, 
                                 vert_loc=vert_loc - vert_gap, xcenter=nextx,
                                 pos=pos, parent=root)
            nextx += dx  # 次のノード位置を更新
    else:
        # リーフノードの位置調整
        nextx = xcenter - 5.0  # リーフノードを少し左に移動
        pos[root] = (nextx, vert_loc)

    return pos

# 決定木を視覚化するための関数
def visualize_decision_tree():
    G = nx.DiGraph()

    # ルートノードを「購入回数」に設定
    G.add_node("購入回数")

    # 購入回数による分割
    for purchase_count in range(6):
        G.add_edge("購入回数", f"購入回数={purchase_count}")
        
        # 性別による分割を追加
        G.add_edge(f"購入回数={purchase_count}", f"購入回数={purchase_count}_男性")
        G.add_edge(f"購入回数={purchase_count}", f"購入回数={purchase_count}_女性")

        # リーフノード（ターゲット予測）を追加
        G.add_edge(f"購入回数={purchase_count}_男性", f"購入={np.random.choice(['購入した', '購入しなかった'])}")
        G.add_edge(f"購入回数={purchase_count}_女性", f"購入={np.random.choice(['購入した', '購入しなかった'])}")

    # 階層レイアウトでノードの位置を計算
    pos = hierarchy_pos(G, "購入回数", xcenter=2.0, horizontal_spacing=4.0)  # 横の間隔と中央を調整
    
    # ノードの描画
    plt.figure(figsize=(12, 8))  # 横幅を大きく設定
    nx.draw(G, pos, with_labels=True, node_color='skyblue', node_size=3000, 
            font_size=12, font_weight='bold', arrows=True, font_family=jp_font.get_name())
    
    plt.title("CHAID決定木の可視化", fontproperties=jp_font)
    plt.show()

# 決定木の視覚化を実行
visualize_decision_tree()

```

    最適な分割は '購入回数' (chi2: 14.1286, p-value: 0.0148)
    


    
![png](output_3_1.png)
    



```python
import numpy as np
import pandas as pd
from scipy.stats import chi2_contingency
import matplotlib.pyplot as plt
import networkx as nx
import matplotlib.font_manager as fm

# 日本語フォントの設定
jp_font_path = 'C:/Windows/Fonts/meiryo.ttc'  # Windows環境でのフォントパス
jp_font = fm.FontProperties(fname=jp_font_path)

# サンプルデータの作成
np.random.seed(42)
data_size = 1000
df = pd.DataFrame({
    '年齢層': np.random.choice(['20代', '30代', '40代'], size=data_size),
    '性別': np.random.choice(['男性', '女性'], size=data_size),
    '購入回数': np.random.randint(0, 6, size=data_size),
    '購入した': np.random.choice(['購入した', '購入しなかった'], size=data_size)
})

# ターゲット変数を数値に変換
df['購入した'] = df['購入した'].apply(lambda x: 1 if x == '購入した' else 0)

# カイ二乗検定の実装
def compute_chi2(data, feature, target='購入した'):
    contingency_table = pd.crosstab(data[feature], data[target])
    chi2, p, dof, expected = chi2_contingency(contingency_table)
    return chi2, p

# 簡易的なCHAIDアルゴリズムの実装
def chaid_decision_tree(data):
    splits = {}
    
    # 初期のカイ二乗計算（購入回数に基づく）
    chi2_purchase, p_purchase = compute_chi2(data, '購入回数')
    splits['購入回数'] = {'chi2': chi2_purchase, 'p_value': p_purchase}
    
    # 初期の結果を表示
    print(f"最適な分割は '購入回数' (chi2: {chi2_purchase:.4f}, p-value: {p_purchase:.4f})")
    
    return splits

# 分割結果を保存する
splits = chaid_decision_tree(df)

# 階層的にノードを配置するためのレイアウト関数
def hierarchy_pos(G, root=None, vert_gap=0.4, vert_loc=0, xcenter=1.0, horizontal_spacing=1.0):
    pos = _hierarchy_pos(G, root, vert_gap, vert_loc, xcenter, horizontal_spacing)
    return pos

def _hierarchy_pos(G, root, vert_gap=0.4, vert_loc=0, xcenter=1.0, horizontal_spacing=1.0, pos=None, parent=None):
    if pos is None:
        pos = {root: (xcenter, vert_loc)}
    else:
        pos[root] = (xcenter, vert_loc)

    children = list(G.neighbors(root))
    if not isinstance(G, nx.DiGraph) and parent is not None:
        children.remove(parent)

    if len(children) != 0:
        dx = horizontal_spacing  # 兄弟ノードの間隔を直接指定
        nextx = xcenter - len(children) * dx / 2 + dx / 2  # ノードの開始位置を調整
        for child in children:
            pos = _hierarchy_pos(G, child, vert_gap=vert_gap, 
                                 vert_loc=vert_loc - vert_gap, xcenter=nextx,
                                 pos=pos, parent=root)
            nextx += dx  # 次のノード位置を更新
    return pos

# 決定木を視覚化するための関数
def visualize_decision_tree():
    G = nx.DiGraph()

    # ルートノードを「購入回数」に設定
    G.add_node("購入回数")

    # 購入回数による分割
    for purchase_count in range(6):
        G.add_edge("購入回数", f"購入回数={purchase_count}")
        
        # 性別による分割を追加
        G.add_edge(f"購入回数={purchase_count}", f"購入回数={purchase_count}_男性")
        G.add_edge(f"購入回数={purchase_count}", f"購入回数={purchase_count}_女性")

        # リーフノード（ターゲット予測）を追加
        G.add_edge(f"購入回数={purchase_count}_男性", f"購入={np.random.choice(['購入した', '購入しなかった'])}")
        G.add_edge(f"購入回数={purchase_count}_女性", f"購入={np.random.choice(['購入した', '購入しなかった'])}")

    # 階層レイアウトでノードの位置を計算
    pos = hierarchy_pos(G, "購入回数", xcenter=6.0, horizontal_spacing=3.0)  # 横の間隔と中央を調整
    
    # ノードの描画
    plt.figure(figsize=(14, 18))  # 横幅を大きく設定

    # ノードを描画
    nx.draw(G, pos, with_labels=False, node_color='skyblue', node_size=3000)
    
    # 男性と女性のノードを斜めに表示
    for node in G.nodes():
        if "男性" in node or "女性" in node:
            x, y = pos[node]
            plt.text(x, y, node, fontsize=12, fontweight='bold', ha='center', va='center', 
                     rotation=30, fontproperties=jp_font)  # 斜めに表示
            
    # その他のノードラベルを表示
    for node in G.nodes():
        if "男性" not in node and "女性" not in node:
            x, y = pos[node]
            plt.text(x, y, node, fontsize=12, fontweight='bold', ha='center', va='center', 
                     fontproperties=jp_font)  # 通常の位置に表示
            

            
    plt.title("CHAID決定木の可視化", fontproperties=jp_font)
    plt.show()
            


# 決定木の視覚化を実行
visualize_decision_tree()

```

    最適な分割は '購入回数' (chi2: 14.1286, p-value: 0.0148)
    


    
![png](output_4_1.png)
    

